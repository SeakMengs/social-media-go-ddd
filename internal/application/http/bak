package http

import (
	"errors"
	"social-media-go-ddd/internal/application/service"
	"social-media-go-ddd/internal/domain/aggregate"
	"social-media-go-ddd/internal/domain/dto"
	"time"

	"github.com/gofiber/fiber/v2"
)

type UserHandlerService struct {
	user    *service.UserService
	session *service.SessionService
	post    *service.PostService
	follow  *service.FollowService
}

func NewUserHandlerService(user *service.UserService, session *service.SessionService, post *service.PostService, follow *service.FollowService) *UserHandlerService {
	return &UserHandlerService{
		user:    user,
		session: session,
		post:    post,
		follow:  follow,
	}
}

type UserHandlerMiddleware struct {
	auth *AuthMiddleware
}

func NewUserHandlerMiddleware(auth *AuthMiddleware) *UserHandlerMiddleware {
	return &UserHandlerMiddleware{
		auth: auth,
	}
}

type UserHandler struct {
	service    *UserHandlerService
	middleware *UserHandlerMiddleware
}

func NewUserHandler(userService *service.UserService, sessionService *service.SessionService, postService *service.PostService, followService *service.FollowService, authMiddleware *AuthMiddleware) *UserHandler {
	return &UserHandler{
		service:    NewUserHandlerService(userService, sessionService, postService, followService),
		middleware: NewUserHandlerMiddleware(authMiddleware),
	}
}

func (h *UserHandler) RegisterRoutes(app *fiber.App) {
	apiUsersProtected := app.Group("/api/v1/users", h.middleware.auth.Handler)
	apiUsersProtected.Get("/me", h.Me)
	apiUsersProtected.Get("/me/posts", h.GetMyPosts)
	apiUsersProtected.Post("/:id/follow", h.FollowUser)
	apiUsersProtected.Delete("/:id/follow", h.UnfollowUser)

	// Public user routes
	apiUsers := app.Group("/api/v1/users")
	apiUsers.Get("/:id", h.GetUserByID)
	apiUsers.Get("/:id/posts", h.GetUserPosts)

	// No middleware route
	apiAuth := app.Group("/api/v1/auth")
	apiAuth.Post("/register", h.CreateUser)
	apiAuth.Post("/login", h.Login)
	apiAuth.Delete("/logout", h.Logout)
}

func (h *UserHandler) CreateUser(ctx *fiber.Ctx) error {
	type request struct {
		dto.NewUser
	}

	var body request
	if err := ctx.BodyParser(&body); err != nil {
		return ErrorResponse(ctx, fiber.StatusBadRequest, err)
	}

	user, err := h.service.user.Create(ctx.Context(), body.NewUser)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	return SuccessResponse(ctx, fiber.Map{
		"user": user,
	})
}

func (h *UserHandler) GetUserByID(ctx *fiber.Ctx) error {
	id := ctx.Params("id")
	user, err := h.service.user.GetByID(ctx.Context(), id)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusNotFound, err)
	}

	return SuccessResponse(ctx, fiber.Map{
		"user": user,
	})
}

func (h *UserHandler) Me(ctx *fiber.Ctx) error {
	user, err := GetUserFromCtx(ctx)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, err)
	}

	return SuccessResponse(ctx, fiber.Map{
		"user": user,
	})
}

func (h *UserHandler) Login(ctx *fiber.Ctx) error {
	type request struct {
		dto.UserLogin
	}

	var body request
	if err := ctx.BodyParser(&body); err != nil {
		return ErrorResponse(ctx, fiber.StatusBadRequest, err)
	}

	user, err := h.service.user.GetByName(ctx.Context(), body.Username)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusNotFound, err)
	}

	if !user.Password.Match(body.Password) {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, "invalid credentials")
	}

	session, err := h.service.session.Create(ctx.Context(), dto.NewSession{
		UserID:   user.ID,
		ExpireAt: time.Now().Add(24 * time.Hour),
	})
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	return SuccessResponse(ctx, fiber.Map{
		"session": fiber.Map{
			"id":        session.ID.String(),
			"expire_at": session.ExpireAt,
		},
		"user": user,
	})
}

func (h *UserHandler) Logout(ctx *fiber.Ctx) error {
	token, err := readBearerToken(ctx)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, err)
	}

	session, err := h.service.session.GetByID(ctx.Context(), token)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, errors.New("invalid session"))
	}

	if err := h.service.session.Delete(ctx.Context(), dto.DeleteSession{
		ID: session.ID.String(),
	}); err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	return SuccessResponse(ctx, nil)
}

func (h *UserHandler) GetMyPosts(ctx *fiber.Ctx) error {
	user, err := GetUserFromCtx(ctx)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, err)
	}

	posts, err := h.service.post.GetByUserID(ctx.Context(), user.ID.String())
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	if posts == nil {
		posts = []*aggregate.Post{}
	}

	return SuccessResponse(ctx, fiber.Map{
		"posts": posts,
	})
}

func (h *UserHandler) GetUserPosts(ctx *fiber.Ctx) error {
	id := ctx.Params("id")
	posts, err := h.service.post.GetByUserID(ctx.Context(), id)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	if posts == nil {
		posts = []*aggregate.Post{}
	}

	return SuccessResponse(ctx, fiber.Map{
		"posts": posts,
	})
}

func (h *UserHandler) FollowUser(ctx *fiber.Ctx) error {
	user, err := GetUserFromCtx(ctx)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, err)
	}

	targetID := ctx.Params("id")
	targetUser, err := h.service.user.GetByID(ctx.Context(), targetID)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusNotFound, err)
	}

	_, err = h.service.follow.Create(ctx.Context(), dto.NewFollow{
		FollowerID: user.ID,
		FolloweeID: targetUser.ID,
	})
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	return SuccessResponse(ctx, nil)
}

func (h *UserHandler) UnfollowUser(ctx *fiber.Ctx) error {
	user, err := GetUserFromCtx(ctx)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusUnauthorized, err)
	}

	targetID := ctx.Params("id")
	targetUser, err := h.service.user.GetByID(ctx.Context(), targetID)
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusNotFound, err)
	}

	err = h.service.follow.Delete(ctx.Context(), dto.DeleteFollow{
		FollowerID: user.ID,
		FolloweeID: targetUser.ID,
	})
	if err != nil {
		return ErrorResponse(ctx, fiber.StatusInternalServerError, err)
	}

	return SuccessResponse(ctx, nil)
}

// Main

package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"os"
	"os/signal"
	"social-media-go-ddd/internal/application/config"
	"social-media-go-ddd/internal/application/http"
	"social-media-go-ddd/internal/application/service"
	"social-media-go-ddd/internal/domain/repository"
	"social-media-go-ddd/internal/infrastructure/persistence/mysql"
	"social-media-go-ddd/internal/infrastructure/persistence/postgres"
	"syscall"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/jackc/pgx/v5/pgxpool"
)

func main() {
	cfg := config.LoadConfig()
	ctx := context.Background()

	if err := cfg.DBDriverValid(); err != nil {
		log.Fatalf("Database driver invalid error: %v", err)
	}

	var pool *pgxpool.Pool
	var mysqlDB *sql.DB

	var err error

	var userRepo repository.UserRepository
	var sessionRepo repository.SessionRepository
	var postRepo repository.PostRepository
	var favoriteRepo repository.FavoriteRepository
	var likeRepo repository.LikeRepository
	var repostRepo repository.RepostRepository
	var followRepo repository.FollowRepository

	switch cfg.DBDriver {
	case config.DB_DRIVER_PG:
		pool, err = postgres.NewPgPool(ctx, cfg.BuildDSN())
		if err != nil {
			log.Fatalf("Failed to create Postgres pool: %v", err)
		}
		defer pool.Close()
		log.Println("Postgres connection pool established")

		userRepo = postgres.NewPgUserRepository(pool)
		sessionRepo = postgres.NewPgSessionRepository(pool)
		postRepo = postgres.NewPgPostRepository(pool)
		favoriteRepo = postgres.NewPgFavoriteRepository(pool)
		likeRepo = postgres.NewPgLikeRepository(pool)
		repostRepo = postgres.NewPgRepostRepository(pool)
		followRepo = postgres.NewPgFollowRepository(pool)
	case config.DB_DRIVER_MYSQL:
		mysqlDB, err = mysql.NewMySQLDB(cfg.BuildDSN())
		if err != nil {
			log.Fatalf("Failed to connect to MySQL: %v", err)
		}
		defer mysqlDB.Close()
		log.Println("MySQL connection established")

		userRepo = mysql.NewMySQLUserRepository(mysqlDB)
		sessionRepo = mysql.NewMySQLSessionRepository(mysqlDB)
		postRepo = mysql.NewMySQLPostRepository(mysqlDB)
		favoriteRepo = mysql.NewMySQLFavoriteRepository(mysqlDB)
		likeRepo = mysql.NewMySQLLikeRepository(mysqlDB)
		repostRepo = mysql.NewMySQLRepostRepository(mysqlDB)
		followRepo = mysql.NewMySQLFollowRepository(mysqlDB)
	}

	userService := service.NewUserService(userRepo)
	sessionService := service.NewSessionService(sessionRepo)
	postService := service.NewPostService(postRepo)
	favoriteService := service.NewFavoriteService(favoriteRepo)
	likeService := service.NewLikeService(likeRepo)
	repostService := service.NewRepostService(repostRepo)
	followService := service.NewFollowService(followRepo)

	authMiddleware := http.NewAuthMiddleware(sessionService, userService)

	userHandler := http.NewUserHandler(userService, sessionService, postService, followService, authMiddleware)
	postHandler := http.NewPostHandler(postService, likeService, repostService, favoriteService, authMiddleware)

	app := fiber.New()
	app.Use(recover.New())
	app.Use(logger.New())

	userHandler.RegisterRoutes(app)
	postHandler.RegisterRoutes(app)

	// Run server on another goroutine such that we can handle graceful shutdown
	go func() {
		fmt.Printf("Server running on port %s\n", cfg.AppPort)
		if err := app.Listen(":" + cfg.AppPort); err != nil {
			log.Printf("Fiber server stopped: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	sigCh := make(chan os.Signal, 1)
	// SIGINT means Ctrl+C, SIGTERM is a termination signal
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	<-sigCh

	log.Println("Shutting down server...")

	if err := app.Shutdown(); err != nil {
		log.Printf("Error during server shutdown: %v", err)
	}

	if pool != nil {
		log.Println("Closing postgres connection pool...")
		pool.Close()
	}

	if mysqlDB != nil {
		log.Println("Closing MySQL connection...")
		if err := mysqlDB.Close(); err != nil {
			log.Printf("Error closing MySQL connection: %v", err)
		}
	}

	log.Println("Cleanup completed. Exiting application.")

	log.Println("Server gracefully stopped.")
}
